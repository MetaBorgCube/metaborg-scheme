module analysis/static-semantics

imports

  signatures/-
  
signature
	namespaces Var

name resolution
  labels
    P

  order
    D < P

  well-formedness
	P*

rules

  init ^ (s) := new s.

  [[ Program(expr) ^ (s) ]] :=
    new m,
    FoldExpr[[expr ^(m)]].
    
  FoldExpr[[ [] ^(_)]].
  
  FoldExpr [[ [DefineSingle(Bind(var, idx), val) | t] ^(p) ]] :=
	new e, e ---> p,
	Expr [[val ^(e)]],
	new s, s ---> p,
  	Var{var} <- s,
  	Var{var}.index := idx,
	// distinct/name W(s)/Var | error $[Redefinition of variable [var]] @var, // This is allowed
  	FoldExpr [[t ^(s)]].
  	
  FoldExpr [[ [RedefineSingle(var, val) | t] ^(s) ]] :=
	new e, e ---> s,
	Expr [[val ^(e)]],
	Var{var} -> s,
  	Var{var} |-> d | error $[Variable [var] is not defined] @var,
  	FoldExpr [[t ^(s)]].
	
  FoldExpr [[ [h|t] ^(s)]] :=
  	new e, e ---> s,
  	Expr [[h ^(e)]],
  	FoldExpr [[t ^(s)]].



  Expr [[ IfElse(cond, then, else) ^(s)]] :=
  	Expr [[cond ^(s)]],
  	Expr [[then ^(s)]],
  	Expr [[else ^(s)]].
  	
  Expr [[ BinOp(op, e1, e2) ^(s)]] :=
  	Expr [[e1 ^(s)]],
  	Expr [[e2 ^(s)]].
  		
  Expr [[ Callcc(exp) ^(s) ]] :=
  	Expr [[exp ^(s)]].
  	
  Expr [[ Set(ref, exp) ^(s) ]] :=
  	Expr [[ref ^(s)]],
  	Expr [[exp ^(s)]].
  	
  Expr [[ Lambda(binds, body) ^(s) ]] :=
  	new let, let ---> s,
  	Map1(Bind) [[binds ^(let)]],
  	Map1(Expr) [[body  ^(let)]].
  	
  Bind [[ Bind(name, idx) ^(s) ]] :=
  	Var{name} <- s,
  	Var{name}.index := idx,
	distinct/name W(s)/Var | error $[Redefinition of variable [name]].
  	
  Expr [[ Ref(name) ^(s) ]] :=
  	Var{name} -> s,
  	Var{name} |-> d | error $[Variable [name] is not defined] @name.
  	
  Expr [[ List(exps) ^(s) ]] :=
    Map1(Expr)[[exps ^(s)]].
 
  Expr [[ Num(_) ^(s) ]].
  Expr [[ Bool(_) ^(s) ]].