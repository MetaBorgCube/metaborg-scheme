module expression

imports
  lib
  
rules
  eval-binop:: ast -> val -> val -> val
  eval-binop(Add(), l, r) = iadd(l, r)
  eval-binop(Sub(), l, r) = isub(l, r)
  eval-binop(Lt(), l, r)  = ilt(l, r)
  eval-binop(Gt(), l, r)  = igt(l, r)
  eval-binop(Or(), l, r)  = ior(l, r)
  eval-binop(And(), l, r) = iand(l, r)
  eval-binop(Eq(), l, r)  = ieq(l, r)
  
  eval-binop(Conz(), l, r) = 
    list <- new(int(2));
    set(list, [0], l);
    set(list, [1], r);
    return(list)
    
  eval-binop(SetCar(), list, val) = 
    v1 <- get(list, [0]);
    set(list, [0], val);
    return(v1)
    
  eval-binop(SetCdr(), list, val) = 
    v1 <- get(list, [1]);
    set(list, [1], val);
    return(v1)
  
rules
  eval-unop:: ast -> val -> val
  eval-unop(Car(), val) =
    return(get(val, [0]))
  eval-unop(Cdr(), val) =
    return(get(val, [1]))
  
rules
  eval-exp:: ast -> val
  eval-exp(Num(v))     = return(int(v))
  eval-exp(EmptyList())= return(new(int(0)))
  eval-exp(Bool("#t")) = return(int(1))
  eval-exp(Bool("#f")) = return(int(0))
  eval-exp(Ref(name))  = return(get(cur(), resolveVar(name)))
  
  eval-exp(Set(Ref(name), exp)) = 
    v1 <- eval-exp(exp);
    path <- resolveVar(name);
    v2 <- get(cur(), path);
    set(cur(), path, v1);
    return(v2)
    
    
  eval-exp(BinOp(Gte(), l, r))  = 
    out <- eval-exp(
      BinOp(Or(), 
        BinOp(Gt(), l, r), 
        BinOp(Eq(), l, r)
      ));
    return(out)
  
  eval-exp(BinOp(Lte(), l, r))  = 
    out <- eval-exp(
      BinOp(Or(), 
        BinOp(Lt(), l, r), 
        BinOp(Eq(), l, r)
      ));
    return(out)
  
  eval-exp(BinOp(op, left, right)) =
    v1 <- eval-exp(left);
    v2 <- eval-exp(right);
    return(eval-binop(op, v1, v2))
    
   eval-exp(UnOp(op, exp)) =
    v1 <- eval-exp(exp);
    return(eval-unop(op, v1))
    
  eval-exp(IfElse(cond, then, else)) =
    c <- eval-exp(cond);
    jumpz(c, ELSE, THEN);
    
   THEN;
    v1 <- eval-exp(then);
    jump(CONT);
   ELSE;
    v1 <- eval-exp(else);
    jump(CONT);
   CONT;
    return(v1)
    
  eval-exp(Let(binds, body)) = 
    scope <- new(int(length(binds)));
    link(scope, [], &P);
    
    eval-let-binds(binds, scope);
    mkcur(scope);
    res <- eval-let-body(body);
    return(res)
    
  eval-exp(FunApp([func | args])) =
    lambda <- eval-exp(func);
    lcf <- closure-to-CF(lambda);
    setCF(lcf, $ret, curCF());
    df <- unpackCF(lcf);
    store-arg(zip-with-index(args), df);
    callCF(lcf);
    return(pop(curCF()))
    
  eval-exp(Lambda(args, body)) = 
    df <- new(int(length(args)));
    link(df, [], &P);
    
    b <- <
      eval-lamb-body(~body)
    >;
    lamb <- mk-closure(df, b, int(1));
    return(lamb)
    
  store-arg:: ast -> val -> instr
  store-arg([], _) = continue()
  store-arg([(idx, exp) | tail], frame) = 
    v1 <- eval-exp(exp);
    set(frame, [idx], v1);
    store-arg(tail, frame)
    
rules // Let internal rules
  eval-let-body:: ast -> val
  eval-let-body([exp]) =
    v1 <- eval-exp(exp);
    return(v1)
      
  eval-let-body([exp | tail]) =
    v1 <- eval-exp(exp);
    return(eval-let-body(tail))
    
  eval-lamb-body:: ast -> return
  eval-lamb-body([exp]) =
    v1 <- eval-exp(exp);
    rcf <- getCF(curCF(), $ret);
    push(v1, rcf);
    returnCF(rcf)
      
  eval-lamb-body([exp | tail]) =
    v1 <- eval-exp(exp);
    eval-lamb-body(tail)
    
  eval-let-binds:: ast -> val -> instr
  // How do we do the empty case?
  // This would require a nop or something
  eval-let-binds([], scope) = continue()
    
  eval-let-binds([Bind(name, val) | tail], scope) = 
    v1 <- eval-exp(val);
    set(scope, resolveVar(name), v1);
    eval-let-binds(tail, scope)
    
    