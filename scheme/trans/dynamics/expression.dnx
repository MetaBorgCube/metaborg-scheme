module expression

imports
  lib
  
rules
  eval-binop(Add(), l, r) = iadd(l, r)
  eval-binop(Sub(), l, r) = isub(l, r)
  eval-binop(Lt(), l, r)  = ilt(l, r)
  eval-binop(Gt(), l, r)  = igt(l, r)
  eval-binop(Or(), l, r)  = ior(l, r)
  eval-binop(And(), l, r) = iand(l, r)
  eval-binop(Eq(), l, r)  = ieq(l, r)
  
  eval-binop(Conz(), l, r) = 
    list <- new(int(2));
    set(list, [0], l);
    set(list, [1], r);
    return(list)
    
  eval-binop(SetCar(), list, val) = 
    v1 <- get(list, [0]);
    set(list, [0], val);
    return(v1)
    
  eval-binop(SetCdr(), list, val) = 
    v1 <- get(list, [1]);
    set(list, [1], val);
    return(v1)
  
rules
  eval-unop(Car(), val) =
    return(get(val, [0]))
  eval-unop(Cdr(), val) =
    return(get(val, [1]))
  
rules
  eval-exp(Num(v))     = return(int(v))
  eval-exp(EmptyList())= return(new(int(0)))
  eval-exp(Bool("#t")) = return(int(1))
  eval-exp(Bool("#f")) = return(int(0))
  eval-exp(Ref(name))  = return(get(cur(), resolveVar(name)))
  
  eval-exp(Set(Ref(name), exp)) = 
    v1 <- eval-exp(exp);
    path = resolveVar(name);
    v2 <- get(cur(), path);
    set(cur(), path, v1);
    return(v2)
    
    
  eval-exp(BinOp(Gte(), l, r))  = 
    out <- eval-exp(
      BinOp(Or(), 
        BinOp(Gt(), l, r), 
        BinOp(Eq(), l, r)
      ));
    return(out)
  
  eval-exp(BinOp(Lte(), l, r))  = 
    out <- eval-exp(
      BinOp(Or(), 
        BinOp(Lt(), l, r), 
        BinOp(Eq(), l, r)
      ));
    return(out)
  
  eval-exp(BinOp(op, left, right)) =
    v1 <- eval-exp(left);
    v2 <- eval-exp(right);
    return(eval-binop(op, v1, v2))
    
   eval-exp(UnOp(op, exp)) =
    v1 <- eval-exp(exp);
    return(eval-unop(op, v1))
    
  eval-exp(IfElse(cond, then, else)) =
    c <- eval-exp(cond);
    jumpz(c, ELSE, THEN);
    
   THEN;
    v1 <- eval-exp(then);
    jump(CONT);
   ELSE;
    v1 <- eval-exp(else);
    jump(CONT);
   CONT;
    return(v1)
    
  eval-exp(Let(binds, body)) = 
    o_scope <- cur();
    scope <- new(int(length(binds)));
    link(scope, [], &P);
    
    eval-let-binds(binds, scope);
    mkcur(scope);
    res <- eval-let-body(body);
    mkcur(o_scope);
    return(res)
    
  
    
  eval-exp(Lambda(args, body)) = 
    df <- new(int(length(args)));
    link(df, [], &P);
    
    b <- <
      eval-lamb-body(~body)
    >;
    clos <- new(int(3));
    set(clos, [0], df);
    set(clos, [1], b);
    set(clos, [2], int(1));
    return(clos)

//  create-clos(df, code) =
//  	clos <- new(int(3));
//  	set(clos, [0], df);
//    set(clos, [1], code);
//    set(clos, [2], int(1));
//    return(clos)
//  	
//  call-clos(clos, next_block, args) =
//  	lcf <- newCF(get(clos, [0]), get(clos, [1]), get(clos, [2]));
//    setC(lcf, $ret, curC(next_block));
//    df <- unpackCF(lcf);
//    store-arg(zip-with-index(args), df);
//    callCF(lcf, get(clos, [1]))
//    
//    
//  eval-exp(Callcc(func)) = 
//    cc <- curC(CONT);
//    
//    // Create wrapping closure
//    cc_df <- new(int(2));
//    set(cc_df, [1], cc);
//    cc_b <- <
//    	v <- get(cur(), [0]);
//    	callC(get(cur(), [1]), v)
//    >;
//    clos_cc <- create-clos(cc_df, cc_b);
//    
//    // Call the closure
//    clos <- eval-exp(func);
//    call-clos(clos, CONT, [clos_cc]);
//   CONT;
//    return(get-returnval())
//    
//  get-returnval() =
//    return(pop(curCF()))
    
    
    eval-exp(Callcc(func)) = 
    cc <- curC(CONT);
    
    cc_clos <- new(int(3));
    clos_b <- <
    	v <- get(cur(), [0]);
    	callC(get(cur(), [1]), v)
    >;
    
    df <- new(int(2));
//    link(df, cur(), &P);
    set(df, [1], cc);
    
    set(cc_clos, [0], df);
    set(cc_clos, [1], clos_b);
    set(cc_clos, [2], int(1));
    
    clos <- eval-exp(func);
    lcf <- newCF(get(clos, [0]), get(clos, [1]), get(clos, [2]));
    setC(lcf, $ret, cc);
    df <- unpackCF(lcf);
    set(df, [0], cc_clos);
    callCF(lcf, get(clos, [1]));
   CONT;
    print(cur());
    return(pop(curCF()))

//  eval-exp(FunApp([func | args])) =
//    closure <- eval-exp(func);
//    call-clos(closure, CONT, args);
//   CONT;
//    return(get-returnval())
    
  eval-exp(FunApp([func | args])) =
    closure <- eval-exp(func);
    lcf <- newCF(get(closure, [0]), get(closure, [1]), get(closure, [2]));
    setC(lcf, $ret, curC(CONT));
    df <- unpackCF(lcf);
    store-arg(zip-with-index(args), df);
    callCF(lcf, get(closure, [1]));
   CONT;
    return(pop(curCF()))
    
rules
  store-arg([], _) = nop()
  store-arg([(idx, exp) | tail], frame) = 
    v1 <- eval-exp(exp);
    set(frame, [idx], v1);
    store-arg(tail, frame)
    
rules // Let internal rules
  eval-let-body([exp]) =
    v1 <- eval-exp(exp);
    return(v1)
      
  eval-let-body([exp | tail]) =
    v1 <- eval-exp(exp);
    return(eval-let-body(tail))
  
  eval-lamb-body([exp]) =
    v1 <- eval-exp(exp);
    rc <- getC(curCF(), $ret);
    callC(rc, v1)
      
  eval-lamb-body([exp | tail]) =
    v1 <- eval-exp(exp);
    eval-lamb-body(tail)

  eval-let-binds([], scope) = nop()
    
  eval-let-binds([Bind(name, val) | tail], scope) = 
    v1 <- eval-exp(val);
    set(scope, resolveVar(name), v1);
    eval-let-binds(tail, scope)
    
    