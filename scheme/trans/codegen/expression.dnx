module expression

rules
  eval-binop:: ast -> val -> val -> val
  eval-binop(Add(), l, r) = iadd(l, r)
  eval-binop(Sub(), l, r) = isub(l, r)
  eval-binop(Lt(), l, r)  = ilt(l, r)
  eval-binop(Gt(), l, r)  = igt(l, r)
  eval-binop(Or(), l, r)  = ior(l, r)
  eval-binop(And(), l, r) = iand(l, r)
  eval-binop(Eq(), l, r)  = ieq(l, r)
  
  eval-binop(Conz(), l, r) = 
    list <- new(int(2));
    set(list, [0], l);
    set(list, [1], r);
    return(list)
    
  eval-binop(SetCar(), list, val) = 
    v1 <- get(list, [0]);
    set(list, [0], val);
    return(v1)
    
  eval-binop(SetCdr(), list, val) = 
    v1 <- get(list, [1]);
    set(list, [1], val);
    return(v1)
  
rules
  eval-unop:: ast -> val -> val
  eval-unop(Car(), val) =
    return(get(val, [0]))
  eval-unop(Cdr(), val) =
    return(get(val, [1]))
  
rules
  eval-exp:: ast -> val
  eval-exp(Num(v))     = return(int(v))
  eval-exp(EmptyList())= return(new(int(0)))
  eval-exp(Bool("#t")) = return(int(1))
  eval-exp(Bool("#f")) = return(int(0))
  eval-exp(Ref(name))  = return(get(cur(), resolve(name)))
  
  eval-exp(BinOp(Gte(), l, r))  = 
    out <- eval-exp(
      BinOp(Or(), 
        BinOp(Gt(), l, r), 
        BinOp(Eq(), l, r)
      ));
    return(out)
  
  eval-exp(BinOp(Lte(), l, r))  = 
    out <- eval-exp(
      BinOp(Or(), 
        BinOp(Lt(), l, r), 
        BinOp(Eq(), l, r)
      ));
    return(out)
  
  eval-exp(BinOp(op, left, right)) =
    v1 <- eval-exp(left);
    v2 <- eval-exp(right);
    return(eval-binop(op, v1, v2))
    
   eval-exp(UnOp(op, exp)) =
    v1 <- eval-exp(exp);
    return(eval-unop(op, v1))
    
  eval-exp(Let(binds, body)) = 
    scope <- new(int(length(binds)));
    link(scope, [], &P);
    
    eval-let-binds(binds, scope);
    mkcur(scope);
    res <- eval-let-body(body);
    return(res)
    
    
rules // Let internal rules
  eval-let-body:: ast -> val
  eval-let-body([exp]) =
    v1 <- eval-exp(exp);
    return(v1)
      eval-let-body([exp | tail]) =
    v1 <- eval-exp(exp);
    return(eval-let-body(tail))
    
  eval-let-binds:: ast -> val -> instr
  // How do we do the empty case?
  // This would require a nop or something
  eval-let-binds([Bind(name, val)], scope) = 
    v1 <- eval-exp(val);
    path <- resolve(name);
    set(scope, path, v1)
    
  eval-let-binds([Bind(name, val) | tail], scope) = 
    v1 <- eval-exp(val);
    set(scope, resolve(name), v1);
    eval-let-binds(tail, scope)
    
    